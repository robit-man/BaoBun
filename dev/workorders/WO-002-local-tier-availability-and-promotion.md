# WO-002: Local Hierarchical Availability And Promotion

## Status
- `state`: `pending`
- `owner`: `unassigned`
- `depends_on`: `WO-001`
- `updates_index`: `required after every completed component`

## Objective
Implement local hierarchical availability tracking (T1/T2/T3), promotion logic, and persistence integration without introducing wire protocol changes yet.

## In Scope
- Tier constants and mapping helpers.
- Local tier bitfields and promotion logic.
- Persistence of tier bitfields in availability store.
- Swarm integration for marking and promoting availability.

## Out Of Scope
- New peer wire messages for tier exchange.
- Compatibility handshake negotiation.
- Scheduler refinement flow across peers.

## Files To Touch (Exact)
- New: `internal/core/availability.go`
- New: `internal/core/tier_availability.go`
- New: `internal/core/tier_availability_test.go`
- Update: `internal/core/availability_store.go`
- Update: `internal/core/swarm.go`
- Update: `README.md`
- Update: `dev/workorders/index.md`

## Component Breakdown

### Component 1: Tier Definitions And Mapping Utilities
#### Implementation Directive
- Add canonical tier sizes in `internal/core/availability.go`:
  - `T1 = 64 KiB`
  - `T2 = 2 MiB`
  - `T3 = 32 MiB`
- Add helpers:
  - `TierBlockCount(fileLen, tierSize) uint64`
  - `TierIndexForOffset(offset, tierSize) uint64`
  - `ChildRange(parentTier, childTier, parentIndex) (start, end uint64)`
  - alignment validation utilities for tier boundaries.
- Keep helpers deterministic and unit-testable.

#### Success State
- Tier math is stable across boundary conditions and final partial block cases.

#### Index Update Requirement
- After completion, set WO-002 Component 1 status in `dev/workorders/index.md` to `completed` and add completion date + commit hash.

### Component 2: TierAvailability Manager
#### Implementation Directive
- Implement `TierAvailability` in `internal/core/tier_availability.go` with:
  - `localT1Have Bitfield`
  - `localT2Have Bitfield`
  - `localT3Have Bitfield`
  - `peerTierHave map[protocol.NodeKey]map[uint8]Bitfield` (reserved for later wire integration)
- Add methods:
  - `MarkT1Complete(unit uint64)`
  - `PromoteIfComplete(tier uint8, index uint64) bool`
  - `HasAtTier(tier uint8, index uint64) bool`
  - `T1RangeForTier(tier uint8, index uint64) (start, end uint64)`
- Promotion rules:
  - Promote T1->T2 when all child T1 set.
  - Promote T2->T3 when all child T2 set.
  - Promotion affects bookkeeping only (no hash/proof logic changes).

#### Success State
- Promotion is correct, idempotent, and handles edge blocks properly.
- Tier bitfields can be queried independently.

#### Index Update Requirement
- After completion, set WO-002 Component 2 status in `dev/workorders/index.md` to `completed` and add completion date + commit hash.

### Component 3: Persist Tier Bitfields
#### Implementation Directive
- Extend `internal/core/availability_store.go` schema with:
  - `t1_have`
  - `t2_have`
  - `t3_have`
- Maintain backward compatibility:
  - missing tier fields should be treated as empty and rebuilt lazily from T1 if needed.
- Validate stored bitfield lengths against computed tier block counts.

#### Success State
- Tier bitfields survive restart and load without recomputation in normal path.
- Backward compatibility with stores generated by WO-001 format is preserved.

#### Index Update Requirement
- After completion, set WO-002 Component 3 status in `dev/workorders/index.md` to `completed` and add completion date + commit hash.

### Component 4: Swarm Integration
#### Implementation Directive
- In `internal/core/swarm.go`:
  - instantiate `TierAvailability` during swarm creation.
  - wire `MarkTransferUnitComplete` to `TierAvailability.MarkT1Complete`.
  - persist tier state on T1 completion and promotion events.
  - expose fa√ßade helpers for future wire/scheduler use:
    - `GetTierSummary(tier uint8, start uint64, length uint64) []byte`
    - `HasTierBlock(tier uint8, index uint64) bool`
- Keep legacy `UploadBitfieldBytes()` behavior unchanged for backward compatibility until WO-003.

#### Success State
- Tier bookkeeping updates during download lifecycle with no protocol behavior regressions.

#### Index Update Requirement
- After completion, set WO-002 Component 4 status in `dev/workorders/index.md` to `completed` and add completion date + commit hash.

## Acceptance Criteria
- Local tier states are correct for partial and complete files.
- Promotions happen exactly when all children are available.
- Tier state persists and reloads correctly after restart.

## Validation Plan
- Unit tests in `internal/core/tier_availability_test.go`:
  - child-range correctness
  - promotion correctness
  - edge block handling
- Extended store tests in `internal/core/availability_store_test.go` for tier fields.

## Risks
- Incorrect tier boundary math can over-advertise availability.
- Backward compatibility bugs if tier fields are assumed always present.

## Rollback Plan
- Keep tier manager side-by-side with legacy behavior; if issues appear, disable promotion writes and rely on T1 only while preserving schema fields.

